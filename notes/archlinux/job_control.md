# Job control
当我们通过`&`在终端运行程序，会让它在后台运行，而使终端能够继续输入其他命令并执行。
```shell
$ ./httpd &
[1] 256591
```
输出中的`[1]`是`作业号（Job number）`，而 **256591** 是PID。

Q: 那么作业是什么，它和进程区别在于？
A: 作业是对于shell执行环境而言的概念，专门指代在当前的shell运行的后台进程，仅对于当前shell环境有用，对于整个操作系统没有意义，而进程是对于整个操作系统而言的概念。至于为什么需要这玩意，我想一方面肯定是历史遗留（比如只有一个终端环境），另一方面也是为了让shell更好的管理当前环境下运行的后台进程。
[]
当后台进程运行完成时，会在终端输出包含作业号的信息。
```shell
[1] + 256591 exit 1 ./httpd
```
`+`表示最近放进后台的进程（可以是挂起的也可以是运行的），`-`表示最近第二个放进后台的进程。
# 前台和后台
将后台进程切换至前台，
```shell
$ fg [%job_number, %job_name, process_id]
```
> 注意，不是在当前shell环境下运行的后台进程是无法被作为作业管理。

# 查看当前作业
通过`jobs`查看作业信息：
```shell
$ jobs
[1] + running ./httpd

$ jobs -l
[1] + 256591 running ./httpd

; zsh未能正确显示
; bash可以
$ jobs -p
256591
```

# 执行命令
```shell
$ jobs -x echo %1
256591
; 输出进程号
```

# Job id
fg,bg,jobs这些命令接受 `作业身份（Job ID）` 作为实参来指定具体的作业。

| Reference | Background job |
| --- | --- |
| %Number | 作业号为Number的作业 |
| %string | 以string开头的命令的作业 |
| %?string | 包含string的命令的作业 |
| %+ | 最近被放进后台的作业 |
| %% | 同上 |
| %- | 最近第二个被放进后台的作业 |

# 挂起作业
按`Ctrl+z`可以将一个正在前台运行的进程挂起，通过`jobs`可以查看，也可以通过bg让它在后台运行，fg让它恢复在前台运行。

# 杀死作业

```shell
$ kill [%job_number]
```
