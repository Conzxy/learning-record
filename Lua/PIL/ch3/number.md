# Numbers
在`Lua5.2`之前，Lua所有数字都是双精度浮点数，即C/C++的double。
`Lua5.3`加入了新的表示方式：64位整数。一般Lua分别称呼为`integer`和`float`（注意float并不是指单精度浮点数，在Lua中，它就是双精度浮点数）。

需要注意的是，由于浮点数的范围问题，所以在5.3之前的程序可能会出现一些不兼容.


# type
注意不论是浮点数还是整数，其type都是number：
```lua
type(3) --> number
type(3.0) --> number
```
理由是因为它们往往是可以互换的（隐式转换）。

如果想要区分它们的类型可以用`math.type()`：
```lua
math.type(3) --> integer
math.type(3.0) --> float
```

# 不同类型的比较
整数和浮点数比较是完全OK的，也符合一般逻辑：
```lua
1 == 1.0
-3 == -3.0
0.2e3 == 200
```

# 十六进制
Lua也支持十六进制，类似C/C++，可以在数字前面加上 `0x` 前缀表示。
但是和其他语言不同的一点在于浮点数也可以支持十六进制表示。
```lua
0x0.2 --> 0.125
```

# 2的幂
可以用 `p/P` 表示2的幂（类似e表示10的幂）。
```lua
0xa.bp2 --> 42.75
```

# 算术运算
Lua支持加减乘除和取模，幂运算。
## 加、减、乘运算
两个操作数都是整数，结果仍是整数；都是浮点数，结果仍是浮点数（符合一般逻辑）。
但如果是混合的，即操作数有浮点数和整数，那么结果是浮点数（将整数转换为浮点数）。

## 除运算
不论如何，结果都是浮点数（换言之默认没有向下取整等取整方式）。
```lua
3.0 / 2.0 --> 1.5
3 / 2 --> 1.5
3 // 2 --> 1
```

## 除运算（取整）
不过在 `Lua 5.3` 引入的新运算符 `//` 可以向下取整，并且对于浮点数和整数都有效。
其结果规则同加、减、乘运算。
```lua
3.0 / 2.0 --> 1.0
3 / 2 --> 1
```

## 取模运算
如果都是整数，结果仍是整数，其余情况结果为浮点数。
```lua
-- 等价形式
a % b == a - ((a // b) * b)

x = math.pi
x - x % 0.01 --> 3.14
x - x % 0.001 --> 3.141
```

# 关系运算符
Lua支持`<`, `>`, `<=`, `>=`, `==`, `~=`，
其中 `~=` 与C/C++的 `!=` 等价。
如果操作数类型不同，那么它们必然是不相等的。
只有当操作数类型相同时，才会按照操作数类型的规则进行比较。

# 数学库（math）
Lua提供标准`math`库，包含三角函数，取整函数，max，min，伪随机数，pi，huge（最大可表示数字）。
```lua
math.sin(math.pi / 2)
math.max(10.4, 7, -3, 20)
math.huge
```
角度和弧度转化函数：
```lua
math.deg(2 * math.pi) --> 360.0
math.rad(180) --> 3.141...
```

## 伪随机数生成器
```lua
-- 均一分布（uniform distribution）
math.random() --> 0.32 -- 产生的数字在[0, 1)内（浮点数）
math.random(2) --> 1.3 -- 产生的数字在[1, n]内（整数）
math.random(2, 10) --> 产生的数字在[2, 10]内（整数）
```
注意，random的实参都是整数，浮点数会报错（x.0不会）。

由于是伪随机数，也提供了随机种子的设置API：
```lua
math.randomseed(os.time())
```
如果要真随机数，那么考虑将随机的熵值作为种子（比如os.time()，设备状态等）

## 取整函数
```lua
math.floor(3.3) --> 3
math.ceil(3.3) --> 4
math.modf(-3.1) --> -3.0 -- 向0取整
```

# 最值常量
```lua
math.maxinteger
math.mininteger
```

注意浮点数有些数字并不能完全用二进制表示，比如1/7，所以会出现一些迷惑操作（一般逻辑）。
```lua
12.7 - 20 + 7.3 ~= 0
```

由于浮点数能保存的整数最大为 $2^53$，所以大于该值会用`科学记数法`（`x.xxxxe+/-xxx`）表示估值。
```lua
math.maxinteger + 1.0 == math.maxinteger + 2.0 --> true
```

# 转换
可以通过给整数`+0.0`强制转化为浮点数
```lua
-3 + 0.0 --> -3.0
0x7fffffffffffffff + 0.0 --> 9.2233720368548e+18
```
对于小于 $2^53$ 的整数，这样是工作良好的。
大于的话会由于损失精度而只能表示为估值：
```lua
(1 << 53) + 1 + 0.0 --> 9.007199254741e+15 ~= (1 << 53) + 1
```

# 与0进行或运算
```lua
2^53 | 0 --> 90071..
3.2 | 0 --> no integer representation
```
没有整数表示的无法转换（即无法用IEEE754表达的浮点数）
