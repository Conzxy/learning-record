# 取模运算
> 读《Linux 多线程服务端编程》 12.3的思考

对于C++的取模运算，在早期C89，C++03，C++98都没有明确表面商是否向0取整还是向下取整。
只要求如下不变式成立：
```c
int r = p / q
int m = p % q

assert(q * r + m == p);
```
如果是向下取整，那么会出现很多反直觉的事，破坏大部分本应工作正常的代码。e.g.
```
-1 / 10 = -1
-1 % 10 = 9
```
我们期望的应当是`-1 % 10 == -1`。

为此，在C89提供`div()`获得向0取整的结果。而到了C99和C++11，语言标准也明确表明商是向0取整，因此这方面可以放心了。
