# 分区存储
> 此为《DDIA》 Ch6的阅读笔记

# What
`分区（partition）`是将一个大的数据集分散到多个节点上，从而提升系统吞吐和存储更大的数据集。<br>
> 另外，除了分区这种称呼的方式外，一般还被称为`分片（Shard）`，区域（region）等。

# Why need(Or useful)
不难想到，分布式系统采用分区存储技术主要是为了提升系统的扩展性（Salability）。<br>
对于整个数据集的一部分请求负载分摊到了不同的节点可以提升整个系统的读写吞吐。<br>

# Hot spot
如果分区本身是不公平的，那么当请求落在一个或特定的几个节点上的时候，会导致系统负载集中在这几个繁忙节点上，而其他空闲节点不处理任何请求。这种现象称为`倾斜（Skewed）`。这几个节点就成为了所谓的`热点（Hot spot）`：不平衡的高负载节点。

一个简单的解决方式是随机分配分区到节点上去，但这种方式一个明显的弊端就是到时候要查询特定的数据项，根本不知道落在哪个节点上，所以此方式必然不可能被实际采用。

# KV分区方式
从大的角度来看，有：
* 范围分区
* 哈希分区

范围分区和哈希分区两种方式的取舍与有序索引和哈希索引类似（私认为）。
## 范围分区
首先明确，键是按照特定的规则（比如小于判别式）排列的。<br>
将键的一个连续范围分配到每个分区上。这样一来，知道范围的边界，通过特定的查询算法（e.g. 二分查找）获取键所在的范围，就能直接知道键应该落在哪个分区中。<br>
关键在于范围边界的选择，选择什么作为边界。边界可能被系统管理员手动指定，也可能由数据库本身管理。

优点：
* 可以轻松实现范围查询（尽管可能需要收集多个节点）
* 对联合索引友好（支持对于联合键\<A, B\>，可以按A或\<A, B\>进行查询）

缺点：
* 对于特定的访问模式，可能会导致热点问题。<br>
  比如用时间戳作为键，那么可能访问的是同一天（比如今天）的记录，那么会导致热点问题出现。


> 该方案被Bigtable, HBase, RethinkDB, MongoDB(before  ver2.4)采用。

## 哈希分区
为了尽可能避免引入倾斜和热点问题，许多数据库采用哈希算法来决定键的落地分区。<br>
因此对于哈希算法，这里需要讨论一下需要考虑那些要素：
* 哈希算法应当对于任何键对于均匀分配，即所谓的`uniform hashing`
* 哈希算法不应当使用各语言内置的哈希算法设施，原因如下：
    * 不同的语言设施底层可能采用的是不同实现，比如A语言可能采用MD5,然而B语言采用MurMur2/3
    * 语言内部设施的哈希函数可能不是合适的
* 不应当使用加密哈希，因为不需要安全性，不应该降低性能

这里安利下[XXHash](https://github.com/Cyan4973/xxHash)，是个高性能的新型哈希函数（README有数据对比）。

缺点：
* 由于哈希函数本身不是按照一定的规则划分范围，因此对于范围查询，不能轻松高效地实现
    * 实际哈希特化的就是点查询（Point query）

> MongoDb支持范围查询，由Mongos向所有节点发送范围查询的请求，收集所有节点的结果并返回

优点：
* 不需要任何特殊处理，克服了范围分区的缺点，对于任何键都可以尽可能平均地分配分区

### 哈希分区完全避免了热点问题？
哈希分区只是能够缓解热点问题，如果大量用户查询同一个键的话，仍然会出现倾斜，导致热点出现。<br>
对于这种情况，大多数数据库都不会自动补偿这样的高倾斜工作负载（即由数据库本身负责减少倾斜），也就是说需要应用开发者去减少倾斜。<br>
一个简单的技术是在这样的键的首或尾添加随机的数字或字母使其随机化，这样即使是同一个键，也会因此分散到多个节点上。<br>
但是，这个手法的弊端十分明显，由于写实际上还是分散到了不同的节点，因此读的时候需要收集多个节点的信息，然后回应客户端，这样反而给节点增加工作负载了。除此之外，还需要知道哪些新键是从原来的键分离出来的，这部分也需要用一些数据结构记录。<br>

> 现在的系统还没有能力自动检测和补偿倾斜工作负载，需要应用开发者自己权衡


# 再平衡分区（Rebalancing partitions）
分区并不是一开始划分好就静止不变了。随着一些事物的变化，可能会需要增加或减少集群中的节点：
* 查询吞吐增加，需要更多的CPU处理请求，减少响应时间
* 数据集增多，需要更多的硬盘或RAM存储数据
* 机器故障，需要其他机器负责故障机器的工作

`再平衡`是指从集群中的一个节点移动负载（数据，读写请求）到同集群中其他节点的过程。

再平衡需要尽可能满足以下要求，以尽可能高性能：
* 再平衡完成后，负载应该与集群中的其他节点公平共享（公平）
* 再平衡过程中，节点应该仍然可以处理请求（仍然工作）
* 不传递不必要的数据，使再平衡快速以减少网络或硬盘IO（避免不必要的IO）

## 哈希再平衡策略
### Mod N
先考虑对节点数目取模的策略，假设节点数目为 `N`，每个节点都有一个索引`I`，
那么通过`Hash(key) % N`得到节点的索引，决定将该键关联的请求路由给它。
对于大小固定的集群而言，这是工作良好的，因为`N`不变，节点之间没有数据迁移的必要。
但是对于大小动态变化，即有扩展或收缩需求的集群而言，这是很糟糕的。
因为可能涉及到多个节点之间相互的数据迁移，需要考虑的节点是混乱的，要维护这样的集群需要很多额外开销，包括内存，网络IO等。

因此 `Mod N` 的做法在实际应用中不可能被采纳。

### 固定分区个数
其实 `Mod N` 的做法就是将每个节点视为一个单独的分区，然后进行数据的分发。
让每个节点都拥有一定数目的分区，但是它们的分区和是一个固定值（假设为`P`），每次对P取模获得分区索引，进而得到节点索引。
这样如果有一个新节点加入集群，那么它只需要从其他的节点将属于它自己的分区索取过来即可，这样只有新节点和其他原有节点之间的数据迁移。
从集群中移除一个节点，也是类似的思路。

这个策略对于P的设置很关键，因为它一旦设置，一般是不会在运行时进行更改。
设置一个
## 范围再平衡策略
